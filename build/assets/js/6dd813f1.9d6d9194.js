"use strict";(self.webpackChunkdatafuse=self.webpackChunkdatafuse||[]).push([[5920],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return d}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),u=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},m=function(e){var n=u(e.components);return r.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=u(t),d=a,b=c["".concat(l,".").concat(d)]||c[d]||p[d]||i;return t?r.createElement(b,s(s({ref:n},m),{},{components:t})):r.createElement(b,s({ref:n},m))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=c;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var u=2;u<i;u++)s[u]=t[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},8430:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return m},default:function(){return c}});var r=t(7462),a=t(3366),i=(t(7294),t(3905)),s=["components"],o={id:"DatafuseQuery-Expression",title:"DatafuseQuery Expression",sidebar_position:2},l="Expression and plan builder",u={unversionedId:"development/rfcs/DatafuseQuery-Expression",id:"development/rfcs/DatafuseQuery-Expression",isDocsHomePage:!1,title:"DatafuseQuery Expression",description:"Summary",source:"@site/docs/development/rfcs/0002-plan-expression.md",sourceDirName:"development/rfcs",slug:"/development/rfcs/DatafuseQuery-Expression",permalink:"/docs/development/rfcs/DatafuseQuery-Expression",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/development/rfcs/0002-plan-expression.md",version:"current",sidebarPosition:2,frontMatter:{id:"DatafuseQuery-Expression",title:"DatafuseQuery Expression",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Proposal: Join framework",permalink:"/docs/development/rfcs/join-framework"},next:{title:"DatafuseQuery Shuffle",permalink:"/docs/development/rfcs/DatafuseQuery-Shuffle"}},m=[{value:"Summary",id:"summary",children:[]},{value:"Expression",id:"expression",children:[{value:"Alias Expression",id:"alias-expression",children:[]},{value:"Materialized Expression",id:"materialized-expression",children:[]},{value:"Expression Functions",id:"expression-functions",children:[]},{value:"Column",id:"column",children:[]},{value:"Expression chain and expression executor",id:"expression-chain-and-expression-executor",children:[]}]},{value:"Plan Builder",id:"plan-builder",children:[{value:"None aggregation query",id:"none-aggregation-query",children:[]},{value:"Aggregation query",id:"aggregation-query",children:[]}]}],p={toc:m};function c(e){var n=e.components,t=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"expression-and-plan-builder"},"Expression and plan builder"),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"Logic plan and expression play a big role throughout the life cycle of SQL query.\nThis doc is intended to explain the new design of expressions and plan builder."),(0,i.kt)("h2",{id:"expression"},"Expression"),(0,i.kt)("h3",{id:"alias-expression"},"Alias Expression"),(0,i.kt)("p",null,"Aliasing is useful in SQL, we can alias a complex expression as a short alias name. Such as:\n",(0,i.kt)("inlineCode",{parentName:"p"},"select a + 3 as b"),"."),(0,i.kt)("p",null,"In the standard SQL protocol, aliasing can work in:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Group By, eg: ",(0,i.kt)("inlineCode",{parentName:"li"},"select a + 3 as b, count(1) from table group by b")),(0,i.kt)("li",{parentName:"ul"},"Having, eg: ",(0,i.kt)("inlineCode",{parentName:"li"},"select a + 3 as b, count(1) as c from table group by b having c > 0")),(0,i.kt)("li",{parentName:"ul"},"Order By: eg: ",(0,i.kt)("inlineCode",{parentName:"li"},"select a + 3 as b from table order by b"))),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"ClickHouse has extended the usage of expression alias, it can be work in:"),(0,i.kt)("pre",{parentName:"div"},(0,i.kt)("code",{parentName:"pre"},"- recursive alias expression: eg: `select a + 1 as b, b + 1 as c`\n\n- filter: eg: `select a + 1 as b, b + 1 as c  from table where c > 0`\n\nNote Currently we do not support clickhouse style alias expression. It can be implemented later.\n")))),(0,i.kt)("p",null,"For expression alias, we only handle it at last, in projection stage. But We have to replace the alias of the expression as early as possible to prevent ambiguity later."),(0,i.kt)("p",null,"Eg:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"select number + 1 as c, sum(number) from numbers(10) group by c having c > 3 order by c limit 10")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Firstly, we can scan all the alias expressions from projection ASTs. ",(0,i.kt)("inlineCode",{parentName:"li"},"c ---\x3e (number + 1)")),(0,i.kt)("li",{parentName:"ul"},"Then we replaced the alias into the corresponding expression in ",(0,i.kt)("em",{parentName:"li"},"having"),", ",(0,i.kt)("em",{parentName:"li"},"order by"),", ",(0,i.kt)("em",{parentName:"li"},"group by")," clause. So the query will be: ",(0,i.kt)("inlineCode",{parentName:"li"},"select number + 1 as c, sum(number) from numbers(10) group by (number + 1) having (number + 1) > 3 order by (number + 1) limit 10")),(0,i.kt)("li",{parentName:"ul"},"At last, when the query is finished, we apply the projection to rename the column ",(0,i.kt)("inlineCode",{parentName:"li"},"(number+1)")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"c"))),(0,i.kt)("p",null,"Let's take a look at the explain result of this query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"| Limit: 10\n  Projection: (number + 1) as c:UInt64, sum(number):UInt64\n    Sort: (number + 1):UInt64\n      Having: ((number + 1) > 3)\n        AggregatorFinal: groupBy=[[(number + 1)]], aggr=[[sum(number)]]\n          RedistributeStage[state: AggregatorMerge, id: 0]\n            AggregatorPartial: groupBy=[[(number + 1)]], aggr=[[sum(number)]]\n              Expression: (number + 1):UInt64, number:UInt64 (Before GroupBy)\n                ReadDataSource: scan partitions: [4], scan schema: [number:UInt64], statistics: [read_rows: 10, read_bytes: 80]\n")),(0,i.kt)("p",null,"We can see we do not need to care about aliasing until the projection, so it will be very convenient to apply other expressions."),(0,i.kt)("h3",{id:"materialized-expression"},"Materialized Expression"),(0,i.kt)("p",null,"Materialized expression processing is that we can rebase the expression as a ",(0,i.kt)("em",{parentName:"p"},"ExpressionColumn")," if the same expression is already processed upstream."),(0,i.kt)("p",null,"Eg:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"select number + 1 as c, sum(number) as d group by c having number + 1 > 3 order by d desc")),(0,i.kt)("p",null,"After aliases replacement, we will know that order by is ",(0,i.kt)("inlineCode",{parentName:"p"},"sum(number)"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"sum(number)")," is already processed during the aggregating stage, so we can rebase the order by expression ",(0,i.kt)("inlineCode",{parentName:"p"},"SortExpression { ... }")," to ",(0,i.kt)("inlineCode",{parentName:"p"},'Column("sum(number)")'),", this could remove useless calculation of same expressions."),(0,i.kt)("p",null,"So ",(0,i.kt)("inlineCode",{parentName:"p"},"number + 1")," in having can also apply to rebase the expression."),(0,i.kt)("h3",{id:"expression-functions"},"Expression Functions"),(0,i.kt)("p",null,"There are many kinds of expression functions."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"ScalarFunctions, One-to-one calculation process, the result rows is same as the input rows. eg: ",(0,i.kt)("inlineCode",{parentName:"li"},"select database()")),(0,i.kt)("li",{parentName:"ul"},"AggregateFunctions, Many-to-one calculation process, eg: ",(0,i.kt)("inlineCode",{parentName:"li"},"select sum(number)")),(0,i.kt)("li",{parentName:"ul"},"BinaryFunctions, a special kind of \xb7ScalarFunctions\xb7 eg: ",(0,i.kt)("inlineCode",{parentName:"li"},"select 1 + 2 ")),(0,i.kt)("li",{parentName:"ul"},"...")),(0,i.kt)("p",null,"For ScalarFunctions, we really don't care about the whole block, we just care about the columns involved by the arguments. ",(0,i.kt)("inlineCode",{parentName:"p"},"sum(number)")," just care about the Column which named ",(0,i.kt)("em",{parentName:"p"},"number")," . And the result is also a column, so we have the virtual method in ",(0,i.kt)("inlineCode",{parentName:"p"},"IFunction")," is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"fn eval(&self, columns: &[DataColumn], _input_rows: usize) -> Result<DataColumn>;\n")),(0,i.kt)("p",null,"For AggregateFunctions, we should keep the state in the corresponding function instance to apply the two-level merge, we have the following virtual method in ",(0,i.kt)("inlineCode",{parentName:"p"},"IAggregateFunction"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"fn accumulate(&mut self, columns: &[DataColumn], _input_rows: usize) -> Result<()>;\nfn accumulate_result(&self) -> Result<Vec<DataValue>>;\nfn merge(&mut self, _states: &[DataValue]) -> Result<()>;\nfn merge_result(&self) -> Result<DataValue>;\n")),(0,i.kt)("p",null,"The process is ",(0,i.kt)("inlineCode",{parentName:"p"},"accumulate"),"(apply data to the function) --\x3e ",(0,i.kt)("inlineCode",{parentName:"p"},"accumulate_result"),"(to get the current state) --\x3e ",(0,i.kt)("inlineCode",{parentName:"p"},"merge")," (merge current state from other state) ---\x3e ",(0,i.kt)("inlineCode",{parentName:"p"},"merge_result (to get the final result value)")),(0,i.kt)("p",null,"ps: We don't store the arguments types and arguments names in functions, we can store them later if we need."),(0,i.kt)("h3",{id:"column"},"Column"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Block")," is the unit of data passed between streams for pipeline processing, while ",(0,i.kt)("em",{parentName:"p"},"Column")," is the unit of data passed between expressions.\nSo in the view of expression(functions, literal, ...), everything is ",(0,i.kt)("em",{parentName:"p"},"Column"),", we have ",(0,i.kt)("em",{parentName:"p"},"DataColumn")," to represent a column."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Clone, Debug)]\npub enum DataColumn {\n    // Array of values.\n    Array(DataArrayRef),\n    // A Single value.\n    Constant(DataValue, usize)\n}\n")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"DataColumn::Constant")," is like ",(0,i.kt)("em",{parentName:"p"},"ConstantColumn")," in ",(0,i.kt)("em",{parentName:"p"},"ClickHouse"),"."),(0,i.kt)("p",null,"Note: We don't have ",(0,i.kt)("em",{parentName:"p"},"ScalarValue")," , because it can be known as ",(0,i.kt)("inlineCode",{parentName:"p"},"Constant(DataValue, 1)"),", and there is ",(0,i.kt)("em",{parentName:"p"},"DataValue")," struct."),(0,i.kt)("h3",{id:"expression-chain-and-expression-executor"},"Expression chain and expression executor"),(0,i.kt)("p",null,"Currently, we can collect the inner expression from expressions to build ExpressionChain. This could be done by Depth-first-search visiting. ExpressionFunction: ",(0,i.kt)("inlineCode",{parentName:"p"},"number + (number + 1)")," will be : ",(0,i.kt)("inlineCode",{parentName:"p"},"[ ExpressionColumn(number), ExpressionColumn(number), ExpressionLiteral(1), ExpressionBinary('+', 'number', '1'), ExpressionBinary('+', 'number', '(number + 1)') ]"),"."),(0,i.kt)("p",null,"We have the ",(0,i.kt)("em",{parentName:"p"},"ExpressionExecutor")," the execute the expression chain, during the execution, we don't need to care about the kind of the arguments. We just consider them as ",(0,i.kt)("em",{parentName:"p"},"ColumnExpression")," from upstream, so we just fetch the column ",(0,i.kt)("em",{parentName:"p"},"number")," and the column ",(0,i.kt)("em",{parentName:"p"},"(number + 1)")," from the block."),(0,i.kt)("h2",{id:"plan-builder"},"Plan Builder"),(0,i.kt)("h3",{id:"none-aggregation-query"},"None aggregation query"),(0,i.kt)("p",null,"This is for queries without ",(0,i.kt)("em",{parentName:"p"},"group by")," and ",(0,i.kt)("em",{parentName:"p"},"aggregate functions"),"."),(0,i.kt)("p",null,"Eg: ",(0,i.kt)("inlineCode",{parentName:"p"},"explain select number + 1 as b from numbers(10) where number + 1 > 3 order by number + 3 ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"| explain                                                                                                                                                                                                                                                                                             |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Projection: (number + 1) as b:UInt64\n  Sort: (number + 3):UInt64\n    Expression: (number + 1):UInt64, (number + 3):UInt64 (Before OrderBy)\n      Filter: ((number + 1) > 3)\n        ReadDataSource: scan partitions: [4], scan schema: [number:UInt64], statistics: [read_rows: 10, read_bytes: 80] |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set (0.02 sec)\n")),(0,i.kt)("p",null,"The build process is"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SourcePlan : schema --\x3e ","[number]"),(0,i.kt)("li",{parentName:"ul"},"FilterPlan: filter expression is ",(0,i.kt)("inlineCode",{parentName:"li"},"(number + 1) > 3"),", the schema keeps the same, schema --\x3e ","[number]"),(0,i.kt)("li",{parentName:"ul"},"Expression: we will collect expressions from ",(0,i.kt)("inlineCode",{parentName:"li"},"order by")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"having ")," clauses to apply the expression, schema --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"[number, number + 1, number + 3]")),(0,i.kt)("li",{parentName:"ul"},"Sort: since we already have the ",(0,i.kt)("inlineCode",{parentName:"li"},"number + 1")," in the input plan, so the sorting will consider ",(0,i.kt)("inlineCode",{parentName:"li"},"number + 1")," as ",(0,i.kt)("em",{parentName:"li"},"ColumnExpression"),", schema --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"[number, number + 1, number + 3]")),(0,i.kt)("li",{parentName:"ul"},"Projection: applying the aliases and projection the columns, schema --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"[b]"))),(0,i.kt)("h3",{id:"aggregation-query"},"Aggregation query"),(0,i.kt)("p",null,"To build ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregation")," query, there will be more complex than the previous one."),(0,i.kt)("p",null,"Eg: ",(0,i.kt)("inlineCode",{parentName:"p"},"explain select number + 1 as b, sum(number + 2 ) + 4 as c from numbers(10) where number + 3 > 0 group by number + 1 having c > 3 and sum(number + 4) + 1 > 4 order by sum(number + 5) + 1;")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"| Projection: (number + 1) as b:UInt64, (sum((number + 2)) + 4) as c:UInt64\n  Sort: sum((number + 5)):UInt64\n    Having: (((sum((number + 2)) + 4) > 3) AND (sum((number + 4)) > 0))\n      Expression: (number + 1):UInt64, (sum((number + 2)) + 4):UInt64, sum((number + 5)):UInt64 (Before OrderBy)\n        AggregatorFinal: groupBy=[[(number + 1)]], aggr=[[sum((number + 2)), sum((number + 5)), sum((number + 4))]]\n          RedistributeStage[state: AggregatorMerge, id: 0]\n            AggregatorPartial: groupBy=[[(number + 1)]], aggr=[[sum((number + 2)), sum((number + 5)), sum((number + 4))]]\n              Expression: (number + 1):UInt64, (number + 2):UInt64, (number + 5):UInt64, (number + 4):UInt64 (Before GroupBy)\n                Filter: ((number + 3) > 0)\n                  ReadDataSource: scan partitions: [4], scan schema: [number:UInt64], statistics: [read_rows: 10, read_bytes: 80]\n")),(0,i.kt)("p",null,"The build process is"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SourcePlan : schema --\x3e ","[number]"),(0,i.kt)("li",{parentName:"ul"},"FilterPlan: filter expression is ",(0,i.kt)("inlineCode",{parentName:"li"},"(number + 3) > 0"),", the schema keeps the same, schema --\x3e ","[number]"),(0,i.kt)("li",{parentName:"ul"},"Expression: Before group by ",(0,i.kt)("inlineCode",{parentName:"li"},"(number + 1):UInt64, (number + 2):UInt64, (number + 5):UInt64, (number + 4):UInt64 (Before GroupBy)"),"\nBefore GroupBy, We must visit all the expression in ",(0,i.kt)("inlineCode",{parentName:"li"},"projections"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"having"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"group by")," to collect the expressions and aggregate functions, schema --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"[number, number + 1, number + 2, number + 4, number + 5]")),(0,i.kt)("li",{parentName:"ul"},"AggregatorPartial: ",(0,i.kt)("inlineCode",{parentName:"li"},"groupBy=[[(number + 1)]], aggr=[[sum((number + 2)), sum((number + 5)), sum((number + 4))]]"),", note that: the expressions are already materialized in upstream, so we just conside all the arguments as columns."),(0,i.kt)("li",{parentName:"ul"},"AggregatorFinal, schema --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"[number + 1, sum((number + 2)), sum((number + 5)), sum((number + 4))]")),(0,i.kt)("li",{parentName:"ul"},"Expression: schema --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"[number + 1, sum((number + 2)), sum((number + 5)), sum((number + 4)), sum((number + 2)) + 4, sum((number + 5)) + 1]")),(0,i.kt)("li",{parentName:"ul"},"Sort: the schema keeps the same"),(0,i.kt)("li",{parentName:"ul"},"Projection: schema --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"b, c"))))}c.isMDXComponent=!0}}]);